// SPDX-License-Identifier: PMPL-1.0-or-later
//! Hesiod zone management: record storage, lookup, and BIND zone file generation.

use std::collections::HashMap;

use anyhow::Result;

use crate::config::HesiodConfig;
use crate::records::*;

/// Key for zone lookups: (name, map_type).
type ZoneKey = (String, MapType);

/// A Hesiod zone holding all records for a domain.
#[derive(Debug, Clone)]
pub struct HesiodZone {
    pub domain: String,
    pub lhs: String,
    pub rhs: String,
    pub ttl: u32,
    records: HashMap<ZoneKey, HesiodRecord>,
}

impl HesiodZone {
    /// Create an empty zone for the given domain.
    pub fn new(domain: &str, lhs: &str, rhs: &str, ttl: u32) -> Self {
        Self {
            domain: domain.to_string(),
            lhs: lhs.to_string(),
            rhs: rhs.to_string(),
            ttl,
            records: HashMap::new(),
        }
    }

    /// Add a record to the zone. The key is derived from the record's name field.
    pub fn add_record(&mut self, name: &str, record: HesiodRecord) {
        let key = (name.to_string(), record.map_type());
        self.records.insert(key, record);
    }

    /// Look up a record by name and map type.
    pub fn lookup(&self, name: &str, map_type: MapType) -> Option<&HesiodRecord> {
        self.records.get(&(name.to_string(), map_type))
    }

    /// Total number of records in the zone.
    pub fn record_count(&self) -> usize {
        self.records.len()
    }

    /// Iterate over all records.
    pub fn records(&self) -> impl Iterator<Item = (&str, &HesiodRecord)> {
        self.records.iter().map(|((name, _), rec)| (name.as_str(), rec))
    }

    /// Build a zone from a `HesiodConfig`.
    pub fn from_config(config: &HesiodConfig) -> Result<Self> {
        let mut zone = Self::new(&config.domain, &config.lhs, &config.rhs, config.ttl);

        for svc in &config.services {
            let record = HesiodRecord::Service(ServiceRecord {
                host: svc.host.clone(),
                port: svc.port,
                protocol: svc.protocol.clone(),
            });
            zone.add_record(&svc.name, record);
        }

        for user in &config.users {
            let record = HesiodRecord::Passwd(PasswdRecord {
                username: user.username.clone(),
                uid: user.uid,
                gid: user.gid,
                gecos: user.gecos.clone(),
                home: user.home.clone(),
                shell: user.shell.clone(),
            });
            zone.add_record(&user.username, record);
        }

        for group in &config.groups {
            let record = HesiodRecord::Group(GroupRecord {
                name: group.name.clone(),
                gid: group.gid,
                members: group.members.clone(),
            });
            zone.add_record(&group.name, record);
        }

        Ok(zone)
    }

    /// Generate a BIND-format zone file string.
    pub fn to_bind_zone(&self) -> String {
        let mut out = String::with_capacity(2048);

        // Header comment
        out.push_str(&format!(
            "; Hesiod zone file for {}\n; Generated by hesiod-dns-map\n\n",
            self.domain
        ));

        // SOA record
        out.push_str(&format!(
            "$ORIGIN {rhs}.\n\
             @ IN SOA ns{rhs}. admin{rhs}. (\n\
             \t2026020801 ; serial\n\
             \t3600       ; refresh\n\
             \t900        ; retry\n\
             \t604800     ; expire\n\
             \t{ttl}        ; minimum TTL\n\
             )\n\n\
             @ IN NS ns{rhs}.\n\n",
            rhs = self.rhs,
            ttl = self.ttl,
        ));

        // Collect records by map type for organized output
        let mut by_type: HashMap<MapType, Vec<(&str, &HesiodRecord)>> = HashMap::new();
        for ((name, map_type), record) in &self.records {
            by_type
                .entry(*map_type)
                .or_default()
                .push((name.as_str(), record));
        }

        let section_order = [MapType::Service, MapType::Passwd, MapType::Group, MapType::Filsys];
        let section_labels = [
            "Service records",
            "Passwd records",
            "Group records",
            "Filsys records",
        ];

        for (map_type, label) in section_order.iter().zip(section_labels.iter()) {
            if let Some(records) = by_type.get(map_type) {
                out.push_str(&format!("; --- {} ---\n", label));
                let mut sorted: Vec<_> = records.clone();
                sorted.sort_by_key(|(name, _)| *name);
                for (name, record) in sorted {
                    out.push_str(&format!(
                        "{name}.{map}{lhs}\t{ttl} HS TXT \"{txt}\"\n",
                        name = name,
                        map = map_type.label(),
                        lhs = self.lhs,
                        ttl = self.ttl,
                        txt = record.to_txt(),
                    ));
                }
                out.push('\n');
            }
        }

        out
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_config() -> HesiodConfig {
        HesiodConfig {
            domain: "test.internal".into(),
            lhs: ".ns".into(),
            rhs: ".test.internal".into(),
            ttl: 300,
            dns_port: 53,
            http_port: 8080,
            services: vec![crate::config::ServiceEntry {
                name: "web".into(),
                host: "web.svc".into(),
                port: 443,
                protocol: "tcp".into(),
            }],
            users: vec![crate::config::UserEntry {
                username: "admin".into(),
                uid: 1000,
                gid: 1000,
                gecos: "Admin".into(),
                home: "/home/admin".into(),
                shell: "/bin/bash".into(),
            }],
            groups: vec![crate::config::GroupEntry {
                name: "ops".into(),
                gid: 1001,
                members: vec!["admin".into()],
            }],
        }
    }

    #[test]
    fn zone_from_config() {
        let config = sample_config();
        let zone = HesiodZone::from_config(&config).unwrap();
        assert_eq!(zone.record_count(), 3);
    }

    #[test]
    fn zone_lookup() {
        let config = sample_config();
        let zone = HesiodZone::from_config(&config).unwrap();

        let svc = zone.lookup("web", MapType::Service).unwrap();
        assert_eq!(svc.to_txt(), "web.svc:443:tcp");

        let user = zone.lookup("admin", MapType::Passwd).unwrap();
        assert!(user.to_txt().starts_with("admin:*:1000"));

        assert!(zone.lookup("nonexistent", MapType::Passwd).is_none());
    }

    #[test]
    fn zone_bind_output() {
        let config = sample_config();
        let zone = HesiodZone::from_config(&config).unwrap();
        let bind = zone.to_bind_zone();

        assert!(bind.contains("$ORIGIN .test.internal."));
        assert!(bind.contains("HS TXT"));
        assert!(bind.contains("web.service.ns"));
        assert!(bind.contains("admin.passwd.ns"));
        assert!(bind.contains("ops.group.ns"));
    }

    #[test]
    fn add_and_lookup_filsys() {
        let mut zone = HesiodZone::new("test.internal", ".ns", ".test.internal", 300);
        zone.add_record(
            "home",
            HesiodRecord::Filsys(FilsysRecord {
                fs_type: "nfs".into(),
                mount_path: "/home".into(),
                source: "nfs:/export".into(),
                mode: "rw".into(),
            }),
        );
        let rec = zone.lookup("home", MapType::Filsys).unwrap();
        assert_eq!(rec.to_txt(), "nfs /home nfs:/export rw");
    }
}
